Este algoritmo otimiza o problema do Ridesharing com janelas de tempo.
Os objetivos são minimizar:

A distância total percorrida pelos veículos.
O tempo total das viagens dos veículos.
O tempo total de viagem dos caronas COMBINADOS.
A quantidade de caronas NÃO COMBINADOS.


Para resolver este problema foi desenvolvido um algoritmo genético baseado no NSGA-II
onde a cada geração é mantida uma população de pais e filhos atualizadas da seguinte forma
no loop principal:

	Pai = melhores(pai + filha);
	Filha = crossover_mutaçao(pai);


									CROSSOVER

A "complicação" do algoritmo está dentro de crossover_mutação. Para que o algoritmo convirja
para as melhores soluções possíveis o crossover faz o seguinte (Para a instância RM698_L15):

Cada Indivíduo da população contem 698 rotas, inicialmente varias. As rotas são sequências de
Services. O service é a informação do que está acontecendo em um determinado ponto (latitude e longitude)
do mapa. Dentro de Service temos os requests que é a informação do veículo ou do carona;

Exemplo de uma rota:

	A+ 1+ 1- 2+ 3+ 3- 2- A-

Cada caracter representa um service. A+ e A- são services diferentes para o mesmo REQUEST (A).

Voltando à questão da rota. Na inicialização da primeira população, cada rota recebe dois services
contendo um veículo do "grafo" (que não é um grafo de verdade, é a estrutura que guarda as informações
de requests do problema). A inicialização se parece com isto:
	A+ A-
	
O ideal é que o veículo seja alocado no seu EARLIEST PICKUP TIME e EARLIEST DEPARTURE TIME. Assim como 
as novas inserções de caronas. Isto porquê maximizamos a chance de fazer um PUSH_FORWARD ao inserir um novo
carona e esta rota se manter válida.
O PUSH_FORWARD é o ato de incrementar os tempos de pickup e delivery dos pontos APÓS o ponto de inserção desejado.

O crossover então pega dois indivíduos, escolhe um ponto de corte aleatório e realiza a permutação dos pedaços
entre um indivíduo e outro. É difícil imaginar um cenário onde a saída do crossover seja um indivíduo melhor do que 
seus pais pois com uma grande quantidade de caronas combinados a chance de obter um indivíduo inválido é bem maior.

É nebuloso o benefício do crossover, mas de toda forma, ao gerar um indivíduo inválido, o operador de reparação
promove um melhoramento do indivíduo. A reparação tenta inserir tantos novos caronas quanto possível 
em pontos aleatórios. Seria interessante testar o algoritmo sem o crossover.

Na verdade o benefício do crossover é quebrar o indivíduo (retirar algumas caronas pra abrir espaço pra outras)
De forma a manter a aparência dos pais.

Uma observação: Na instância RM698_L15 os veículos estão ordenados da maior distância pra menor. Como o crossover
sempre preserva as rotas que estão ACIMA do ponto de corte, parece menos provável que os primeiros veículos
serão alterados pelo operador de reparação. 




									INICIALIZAÇÃO DOS MATCHABLE_RIDERS
									
No início do algoritmo precisamos verificar quais riders podem ser combinados com quais veículos.
Essa lista otimiza o operador de reparação e o de mutação. já que a busca por novas inserções se restringe à
lista de riders cada veículo e não a todo espaço de riders.

Essa verificação tem que ser feita da seguinte forma. consideremos as janelas de tempo de um veículo e um carona:

Veículo		|----------|                |---------|
Carona		        |------|        |------|
Este caso está ok, as janelas de tempo se sobrepõem.

Veículo		|----------|                |---------|
Carona		        |------|                        |------|
Este caso não. A janela de delivery do carona está fora da janela do veículo:

Veículo		|----------|                |---------|
Carona		        |------|    |------|
Este caso também vale.

Veículo		|----------|                |---------|
Carona	 |------|                             |------|
Este caso também vale!

Para as janelas de tempo sere válidas tempos de que ter:

LATEST PICKUP TIMEc >= EARLIEST PICKUP TIMEi
EARLIEST DELIVERY TIMEc <= LATEST DELIVERY TIMEi

Ok, definimos as validações da janela de tempo. Mas e o máximo de detour do veículo?

		V+           V-
		 \         /
		  \C+---C-/

Distância D = (C-,V-)
Distância D2 = (V+,C+)
Distância D3 = (C+,C-);

LatestInserçãoCarona = LatestDeliveryTIMEv - D;
EarliestInserçãoCarona = EarliestDeliveryTIMEV - D;
EarliestPickupInserçãoCarona = EarliestPickupTIMEv + D2;
LatestPickupInsarçãoCarona = LatestPickupTIMEv + D2;

Essas quatro variáveis são a janela de inserção de pickup e delivery do carona que o veículo de fato pode atender
(levando em conta o tempo que leva pra chegar no carona).
Isto é, o earliest, latest pickup time e earliest latest delivery time que o veículo pode atender o carona.

Desta janela de inserção, deduzimos a janela REAL onde cada um pode ser atendido:
O earliest pickup time em que o veículo PODE atender o carona e que o carona PODE ser atendido. (M)
O latest pickup time em que o veículo PODE atender o carona e que o carona PODE ser atendido. (N)
O earliest delivery time em que o veículo PODE atender o carona e que o carona PODE ser atendido. (O)
O latest delivery time em que o veículo PODE atender o carona e que o carona PODE ser atendido. (P)


	Veículo 					A|--------|B             C|-----------|D
								 \         \              /           /
	Janela de inserção   	      E|--------|F          G|-----------|H
	Janela do carona          I|---------|J                    K|-----------|L
	Janela real                   M|-----|N                    O|----|P


					     Verificando se dá pra fazer a inserção;
					     
if (J < E || K  >  H)
	CARONA INVÁLIDA!, nem calcula a janela real;
	
calcula_janela_real;
if (N < M || P < O)
	CARONA INVÁLIDA!
	
pickup = M
delivery = M + D3;
if (delivery > P)
	CARONA INVÁLIDA!
if (delivery < O){
	MAXeXTRAtIME = 0.3 * D3;
	
	if (delivery + MAXeXTRAtIME >= O){
		CARONA VÁLIDA!
	}
	else{
		delivery = O;
		pickup = delivery + MAXeXTRAtIME - D3;
		if (pickup > N)
			CARONA INVÁLIDA!
	}
}

Se chegou a qui, a carona é válida e seus valores de pickup e delivery são
pickup e delivery;






		  


















